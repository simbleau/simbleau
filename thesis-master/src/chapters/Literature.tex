\chapter{Literature review}\label{sec:literature_review}

Modern 2D GPU vector graphic rendering on the GPU is a culmination of impressive research. Insights include tessellation triangle-batching\cite{Silva18}, stencil-buffer curve rendering\cite{Loop05}, random-access vector graphics\cite{Nehab08}, a massively parallel pipeline\cite{Ganacim14}, novel scan-line algorithms\cite{Li16}, and GPU architecture leveraging\cite{Levien20}. These findings have been integrated into many technologies, both individuals and entities. This section aims to survey notable vector rendering methods that expose field advancements to the modern-day. We attempt to qualify significance at a high level.

\section{Technologies}

Listed below are projects of significance due to popularity, performance, or variance in methodology. These technologies would justify first-class support in our analytic tool.

\subsection{Skia}\label{sec:skia}
\textit{Skia}\footnote{see: \href{https://skia.org}{https://skia.org}} is the most widely used C++ 2D hardware-accelerated graphics library with support for vector graphics. The library has had commercial support from Google since 2005 while being open source\cite{Skia}. \textit{Skia} is used for rendering in Mozilla Firefox and Google Chrome web browsers, making it one of the most established graphic libraries.

The greatest difficulty with \textit{Skia} is complexity. \textit{Skia} is very feature-rich, supporting CPU and GPU rendering, multiple input and output formats, filters, color spaces, and color types. The project is over 370,000 lines of code, excluding dependencies. With dependencies, the project amasses over 7,000,000 lines of code and requires 8 gigabytes of disk space to be built. In addition, the final binary is 3-8 megabytes, depending on enabled features, causing contention for those optimizing bundle size. In addition, \textit{Skia} can only be built with \textit{clang}\footnote{see: \href{https://clang.llvm.org/}{https://clang.llvm.org/}} and requires an obscure build system called \textit{gn}\footnote{see: \href{https://gn.googlesource.com/gn/}{https://gn.googlesource.com/gn/}} which uses \textit{Python 2}. The complex library is old and complicated to work with, while most contributions originate from Google engineers and affiliates directly, rather than interested volunteers. The renderer technology features a vector logo, shown below in \cref{fig:skia_logo}.\medskip

\smallsvg
% Path
{assets/Skia_Project_Logo.svg}
% Caption
{The \textit{Skia} Logo.\label{fig:skia_logo}}
% Attribution
{\href{https://skia.org}{https://skia.org/, Fair use}}

\subsection{Pathfinder}\label{sec:Pathfinder}

\textit{Pathfinder}\footnote{see: \href{https://github.com/servo/pathfinder}{https://github.com/servo/pathfinder}} is a new, sophisticated 2D renderer designed for vector and font rendering. The renderer gains applause because it renders paths in a performant, analytic way. \textit{Pathfinder} decomposes a very complex vector object into many smaller and simpler objects stored in a tiled lattice. Next, the library determines which tiles are occluded and enforces a culling policy on occluded shapes. These opaque tiles are submitted as a batch of instanced quads, minimizing redraw on pixels encountered in a traditional painter's algorithm. Quad batching allows more time to be spent on busier sections of the image and keeps the rest of the image inexpensive to draw\cite{Pathfinder_Features}.\medskip

To visualize how much overdraw a general example incurs with a traditional painter's algorithm, we present \cref{fig:ghostscript_overdraw} below with two versions of ``\textit{Ghostscript Tiger}.'' The left tiger paths are stripped of color value and replaced with a translucent white fill to visualize overlapping shapes easily. Hence, the whiter the pixel, the more times the pixel is drawn without occlusion culling. The methodology for generating this image is described in \cref{appendix:overdraw}.

\widesvg
% Path
{assets/Ghostscript_Tiger_Overdraw.svg}
% Caption
{``\textit{Ghostscript Tiger}'' shape overlap without occlusion culling (left) and original fill (right).\label{fig:ghostscript_overdraw}}
% Attribution
{\href{https://nical.github.io/posts/a-look-at-pathfinder.html}{By Nicolas Silva, modifications by Spencer C. Imbleau, MIT}}
\medskip

Historically, \textit{Pathfinder} was slighted to be used in the Servo\footnote{see: \href{https://servo.org/}{https://servo.org/}} mission, which once shared code with Mozilla Firefox as an open-source embedded web engine. However, \textit{Pathfinder} has lacked consistent development in its lifetime from the leading developer, Patrick Walton, and has suffered many backwards incompatible re-writes. Nevertheless, the project still remains useful for critique and analysis\cite{Silva19}. The renderer technology features a vector logo, shown below in \cref{fig:pathfinder_logo}.

\smallsvg
% Path
{assets/Pathfinder_Logo.svg}
% Caption
{The \textit{Pathfinder 3} logo.\label{fig:pathfinder_logo}}
% Attribution
{\href{https://github.com/servo/pathfinder}{Pathfinder, MIT/Apache 2.0}}
\medskip

\subsection{piet-gpu}\label{sec:piet-gpu}
\textit{piet-gpu}\footnote{see: \href{https://github.com/linebender/piet-gpu}{https://github.com/linebender/piet-gpu}} is an experimental prototype 2D GPU renderer currently in development, and relatively stable. The renderer features a novel compute-centric pipeline. The prototype is a retained-mode renderer, buffering scene-graph fragments on the GPU to accelerate static continuity. In addition, \textit{piet-gpu} offers a portable runtime and compatibility fallback, making the renderer relatively general purpose. The research has contributed impressive results, namely with leveraging a sort-middle GPU architecture\footnote{see: \href{https://raphlinus.github.io/rust/graphics/gpu/2020/06/12/sort-middle.html}{https://raphlinus.github.io/rust/graphics/gpu/2020/06/12/sort-middle.html}}.

\subsection{Spinel}\label{sec:spinel}

Lastly, \textit{Spinel}\footnote{see: \href{https://fuchsia.googlesource.com/fuchsia/+/refs/heads/main/src/graphics/lib/compute/spinel}{https://fuchsia.googlesource.com/fuchsia/+/refs/heads/main/src/graphics/lib/compute/spinel}} is a perplexing renderer developed by Google, with little outside details. The future technology is self-described by Google as ``a high-performance GPU-accelerated vector graphics, compositing and image processing pipeline''\cite{Spinel}. The technology currently exists as a graphics API in Google's new operating system, \textit{Fuchsia}\footnote{see: \href{https://fuchsia.dev/}{https://fuchsia.dev/}}, but is likely to be integrated into \textit{Skia} and follows a similar role. For now, the project is experimental and locked behind Google's operating system. Moreover, building and running Spinel is onerous, with little information to an end-user. For these reasons, working fluidly with Spinel may be oppressively difficult for the discernible future. However, promises Spinel makes are exciting, such as inexpensive redraw, extensibility for animation, entirely GPU-processed pipeline, and explicit support for paths, styling, and composition\cite{Spinel_Features}.

\subsection{Lyon}\label{sec:lyon_lit}
Lyon\footnote{see: \href{https://github.com/nical/lyon}{https://github.com/nical/lyon}} is not a vector renderer, instead it is a mature tessellator. However, Lyon is very popular because it abstracts away the difficulty of vector primitives via substitution, which integrates into a traditional raster pipeline with little to no GPU features\cite{Lyon}. Lyon implements an efficient sweep-line algorithm, traversing a shape from top to bottom with a knowledge of local geometry\cite{Lyon_Sweep}, although there are many methods. Such methods include constrained Delaunay triangulation\cite{Chew87} which may be hardware-accelerated\cite{Qi12} and ear clipping\cite{Eberly02}.\medskip

\smallsvg
% Path
{assets/Lyon_Logo.svg}
% Caption
{The logo for project Lyon.}
% Attribution
{\href{https://github.com/nical/lyon}{Lyon, modifications by Spencer C. Imbleau, MIT/Apache 2.0}}
\medskip

\section{Research}
Listed below are significant research advancements in arithmetic, theory, or results. This research is attractive to those wishing to join the field or seek more detail into the space.

\subsection{Improved Alpha-Tested Magnification for Vector Textures and Special Effects}\cite{Green07}

Originally a product of Valve, this research was presented at SIGGRAPH in 2007 as a novel encoding of raster images to improve the magnification of textures with low storage requirements efficiently. These encodings are signed distance fields, or \emph{SDFs}. Rendering SDFs requires low hardware requirements and a trivial shader for the GPU. In addition, the model provides support for anti-aliasing and considerable up-scaling to traditional textures, making the research attractive to game developers. Given multiple channels, scaling can also be improved\cite{Chlumsky17}, shown in \cref{fig:sdf}. While SDFs are not a vector graphics model, the encoding is worth mentioning due to its popularity and similarity. It is also worth noting that generating an SDF requires a significant amount of computational resources and is typically done on the CPU, making it a pre-baked asset not suitable for dynamic rendering.\medskip

\widesvg
% Path
{assets/SDFs.svg}
% Caption
{Low-resolution SDF upscaling (left), high-resolution SDF upscaling (middle), and multi-channel low-resolution SDF upscaling (right).\label{fig:sdf}}
% Attribution
{\href{https://doi.org/10.1111/cgf.13265}{Improved Corners with Multi-Channel Signed Distance Fields, Fair Use}}
\medskip

\subsection{Resolution Independent Curve Rendering Using Programmable Graphics Hardware}\cite{Loop05}\label{sec:LoopBlinn}

Presented at SIGGRAPH Asia in 2005 and published in the ACM Transactions on Graphics (TOG), Microsoft researchers Charles Loop and James Blinn presented the first major analytic algorithm to render resolution-independent vector graphics using programmable graphics hardware. The method constructs vector images from mosaics of triangulated Bézier control points using a newly conceptualized \emph{stencil buffer} data structure. The method worked in two passes. First, a hull of triangles constructed asserts the shape's fill using a stencil buffer. After fill is determined, a second pass is required to cut out the fragments with a shader. The shader is, similar to SDFs, trivial. The shader algorithm functions by assigning varyings \(u, v)\) to the control points of a quadratic Bézier curve, discarding the fragment under a retention policy. The shader's retention policy is denoted below in \cref{eq:loop_blinn_shader}.\medskip

\tocequation{Retention equation of Loop-Blinn fragment shader.}
\begin{center}
Given control points \(P_0\), \(P_1\), and \(P_2\),\\
apply varyings \((u, v) = (0, 0), (0.5, 0), (1, 1)\),
\end{center}
\begin{equation}\label{eq:loop_blinn_shader}
    \begin{split}
        u^2 - v \ge 0 & \text{: Discard fragment} \\
        u^2 - v < 0 & \text{: Keep fragment}
    \end{split}
\end{equation}
\medskip


\subsection{Random Access Vector Graphics}\cite{Nehab08}\label{sec:RAVG}

Presented at SIGGRAPH Asia and published by the ACM ToG in 2008, Diego Nehab and Hugues Hoppe created a tiling approach for vector graphics based on a considerable upfront computation expense. This pre-computation model enhanced the image's interactivity by providing an approach to redraw mapped vector images on arbitrary objects inexpensively. This technique significantly extended the ability to render static vector graphics (with support for transformations) at interactive rates. The pre-computation method required considerable resources to cache, making the process impossible for interactive applications that may deform the vector texture. In practice, the approach encoded ``\textit{Ghostscript Tiger}'' in 0.44 seconds\cite{Nehab08}, which is not a challenging render by modern standards.\medskip

\smallsvg
% Path
{assets/Ghostscript_Tiger.svg}
% Caption
{Ghostscript Tiger}
% Attribution
{\href{http://www.gnu.org/licenses/agpl.html}{Ghostscript authors, AGPL}}\medskip

\section{High Performance Software Rasterization on GPUs}\cite{Laine11}
Authors Samuli Laine and Tero Karras, researchers from NVIDIA, had their work published at the ACM SIGGRAPH Symposium in 2011. Their implementation ``CUDA Raster'' was easily extensible and featured a traditionally software-based graphics pipeline on a GPU, which obeyed ordering constraints from traditional rendering pipelines. Their performance improved the CPU-based equivalence by 2–8x, comparing the approach to a top-of-the-line GPU in 2011. This research did not focus on vector graphics but set up many theories behind compute-based parallel rendering.

\subsection{GPU-Accelerated Path Rendering}\cite{Kilgard12}
Presented at SIGGRAPH Asia and published by the ACM ToG in 2012, Mark J. Kilgard and Jeff Bolz released one of the first analytic rendering approaches to 2D vector graphics on the GPU. Their approach builds upon existing techniques for curve rendering, specifically the stencil buffer technique\footnote{see: \cref{sec:LoopBlinn}}. Kilgard and Bolz however explicitly decouple the stencil step to determine path fill and stroked coverage with parallelism.

\subsection{Massively Parallel Vector Graphics}\cite{Ganacim14}
Published in the ACM ToG and Proceedings of ACM SIGGRAPH Asia 2014, Ganacim et al. reached higher levels of parallelization in vector graphics rendering. This solution further builds on previous models by Diego Nehab\footnote{see: \cref{sec:RAVG}}, which applied deformations and warps to vector graphics on arbitrary surfaces but optimized the pipeline for dynamism. The rendering pipeline divides into a pre-processing component that builds a novel, the shortcut tree, and a rendering component that processes all samples and pixels in parallel. As a result, tree construction is efficient and parallel at the segment level, enabling dynamic vector graphics.

\widesvg
% Path
{assets/Massively_Parallel_Hawaii.svg}
% Caption
{Massively parallel vector graphics rendered under a perspective warp.}
% Attribution
{\href{https://w3.impa.br/~diego/projects/GanEtAl14/index.html}{Massively-Parallel Vector Graphics by Ganacim et al., Fair Use}}\medskip

\subsection{Efficient GPU Path Rendering Using Scanline Rasterization}\label{sec:scanline_vg}\cite{Li16}
Published in the ACM ToG and presented in SIGGRAPH Asia 2016, Li et al. released a significant milestone in vector graphics rendering. The solution is parallel, optimized, and supports dynamism inherently. The methods presented parallelize over boundary fragments (pixels intersecting the path boundary), and non-boundary pixels process in bulk, similar to CPU scanline rasterizers. This novel scanline algorithm significantly saves on the number of winding number computations. To this day, it remains one of the fastest methods for rasterization and GPU efficiency. Moreover, it supports animated input and outperforms many state-of-the-art alternatives.

\subsection{Bay Area Rust March 2017: GPU Rasterization}\cite{Walton18}
Patrick Walton was given a feature panel in Air Mozilla's Bay Area Rust event in March 2017, where he discussed his project \textit{Pathfinder}\footnote{see also: \cref{sec:Pathfinder}}. During his presentation, he exposed the implementation in an easily accessed format. He noted \textit{Pathfinder} uses tessellation to split curved shape edges into small line fragments within an arbitrary tolerance (3 pixels) using tessellation shaders. In the fragment shader, \textit{Pathfinder} calculates the area defined by the bound tessellation fragments and stores the area relative to those around it in a novel way called \textit{delta coverage}. After computing the delta coverage, \textit{Pathfinder} sweeps every column in parallel to calculate the coverage in a prefix sum which translates to the winding fill rule for every pixel.

\subsection{Sort-Middle Architecture}\cite{Levien20}
Dr. Raph Levien's research blog defined a new architecture merged into his renderer ``\textit{piet-gpu}'', further mentioned in \cref{sec:piet-gpu}. As described in the blog post,
\begin{quote}
\textit{The architecture calls for sorting in the middle of the pipeline, so that in the early stage of the pipeline, (2D) triangles can be processed in arbitrary order to maximally exploit parallelism, but the output (2D) render still correctly applies the triangles in order.}\cite{Levien20}
\end{quote}
This research has helped \textit{piet-gpu} to be a modern, experimental solution to dynamic vector rendering with support for mass input and animation. The architecture explains that the motivation for this compute-centric pipeline is to maximize parallelism. Dr. Raph Levien accomplished this through a multi-stage compute-centric pipeline with a sorting procedure in the middle. The performance claims and results listed display \emph{signifcant} results for \textit{piet-gpu} on NVIDIA\copyright hardware in \cref{fig:sort-middle-results}, and work is still ongoing\footnote{see: \href{https://github.com/linebender/piet-gpu}{https://github.com/linebender/piet-gpu}}. Dr. Raph Levien's blogs\footnote{see: \href{https://raphlinus.github.io/}{https://raphlinus.github.io/}} have been insightful and reputable as a source of vector graphic field study and advancement in recent years.\medskip

\widesvg
% Path
{assets/Sort_Middle_NVIDIA_Results.svg}
% Caption
{Sort-middle-architecture performance on NVIDIA\copyright hardware\label{fig:sort-middle-results}}
% Attribution
{\href{http://www.gnu.org/licenses/agpl.html}{By Raph Levien, AGPL}}\medskip

