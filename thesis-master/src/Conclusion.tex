\section{Conclusion}

\subsection{Review}\label{sec:conclusion}
Vector graphics pose unique properties which make the imaging model ideal for users who value resolution independence, storage footprint, or seek to benefit from implicit modeling. While the field is optimistic with experimentation and research, new and old technologies lack comprehensive performance comparison. Users seeking to integrate a rendering backend have little more than cursory time trials or \emph{Big-O} to encourage adoption, which is often insufficient.\medskip

This entanglement of information among technology is an opportunity for further understanding. Analyzing performance on the GPU is \emph{hard}. Our research sets a precedent to deobfuscate the field of hardware-accelerated vector graphics with a novel benchmarking framework. Our tool's extensible design and integration into GPU analysis tools will begin to rectify the inadequate comparative research. We justified our framework's design decisions through methodology and a pilot test trial, which collected results defending our synthesized theories.\medskip

While \toollinkedname is the first step in bringing enhanced optics and context to eclectic options, there is still available work.\medskip

\subsection{Future Work}\label{sec:future_work}

In this section, we provide opinions on how to improve both the imaging model for vector graphics and our framework's usefulness.

\subsubsection{Research focus}
Results presented in our test case support a theory that compute-centric approaches which extend the flexibility of compute-shaders to leverage more parallelism in the vector imaging model are promising. On the contrary, tessellation and pre-computation-based approaches may be convenient for static vector rendering but do not encourage further research, given their anti-thetic consequences to the imaging model. New research is needed to extend the flexibility of low-level GPU features and maximize parallelism in a way that does not inhibit any benefits discussed in the background (\cref{sec:background}).

\subsubsection{Tooling}
Currently, tooling for vector graphics is poor. Most people may be familiar with excellent software such as Adobe Illustrator\footnote{\href{https://www.adobe.com/products/illustrator.html}{https://www.adobe.com/products/illustrator.html}} or Inkscape\footnote{\href{https://inkscape.org/}{https://inkscape.org/}} for composing vector graphics, but there is almost no free or open-source tooling for animation. This lack of tooling has likely discouraged adoption for artists and developers alike. Failed standards on how to encode animation such as the ``\textit{SMIL}'' format have also come and gone, failing to reach adoption with eventual deprecation\footnote{\href{https://developer.mozilla.org/en-US/docs/Web/SVG/SVG_animation_with_SMIL}{https://developer.mozilla.org/en-US/docs/Web/SVG/SVG\_animation\_with\_SMIL}}.\medskip

\subsubsection{Encoding}
The \textit{svg} specification is built on \textit{xml}, an extremely verbose format with repeating tags and redundant information. While this format is still generally more lightweight than raster graphics (\cref{sec:storage_savings}), compression can improve file storage and empirical benefits such as network throughput.\medskip

Another issue is standardization. The bloated \textit{svg} specification is an inhibitor of vector graphic rendering implementations, with full implementations being relatively rare, even in web browsers with commercial support. Future specifications should abbreviate current features, such as subdividing higher-dimension Bézier curves into piece-wise quadratic Bézier curves or flattening text into paths. A simpler specification would facilitate faster standardization but require tooling to adopt such output formats, which is a hard sell.

\subsubsection{API enhancements}
Since Rust is still in its infancy as a language, it is missing some key language features which would empower a more intuitive API.\medskip

\paragraph{Integration}
As the framework's ecosystem receives adoption, people will want to test against certain renderers or tessellators. The traits provided in the ``\textit{render-kit}'' and ``\textit{tessellation-kit}'' features provide a convenient interface and pre-written tests, although it would be beneficial if users could add modular dependencies which provide certain renderers, such as \textit{Pathfinder}\footnote{\href{https://github.com/servo/pathfinder}{https://github.com/servo/pathfinder}}, or certain tessellators, such as \textit{Lyon}\footnote{\href{https://github.com/nical/lyon}{https://github.com/nical/lyon}}, to test against.

\paragraph{Variadic generics}
Variadic generics are the ability to enable traits, functions, and data structures to be generic over a variable number of types. Currently, a monitor delegated to a \code{Benchmark} is passed as a \code{Box<dyn Monitor>}, where \code{Monitor} is a trait. Thus, trait objects are handled by a collection (\code{Vec}) for dispatch when polling the collection of monitors.\medskip

This relatively minor inconvenience incurs some runtime overhead due to dynamic dispatch. On the other hand, variadic generics would make polling invocations and memory access slightly faster with static dispatch and stack-allocated monitors. An example of what variadic generics could be semantically is in \cref{code:variadic_generics} below.

\begin{snippet}
\caption{Theoretic variadic generic usage in \toollinkedname.}\label{code:variadic_generics}
\begin{minted}{rust}
fn poll_monitors<...M: Monitor>(monitors: (...M)) {
    for monitor in ...monitors {
        monitor.poll();
    }
}

let cpu_mon = (CpuUtilizationMonitor::new());
let hb_mon = (HeartbeatMonitor::new());
let mixed_mon = (CpuUtilizationMonitor::new(), HeartbeatMonitor::new());

poll_monitors(cpu_mon);
poll_monitors(hb_mon);
poll_monitors(mixed_mon);
\end{minted}
\end{snippet}
\medskip

\paragraph{Parallel runtime execution in \code{Driver}}
The \code{Driver} is designed in such a way to execute benchmarks sequentially, as to eliminate interference. However, one may be a concerned with ``how x performs while y''. In such a case, this can currently be performed by launching two threads with two drivers, or two threads within a closure, but this is tedious ceremony that we would like to provide an API for.\medskip

\paragraph{Asynchronous API}
Currently, our \code{Driver} data structure is a synchronous runtime executor for benchmarks. While this works, extending the runtime further with parallel computing and asynchronous programming should be possible. Independent tasks, such as polling with a \code{Monitor}, could be faster and less resource-hungry asynchronously than with multi-threading.\medskip

Currently, async closures are unstable as of Rust 1.59. Our methodology prohibited using unstable features in data collection code as a design philosophy. Therefore, \toollinkedname must wait for feature stabilization to declare asynchronous benchmark declarations. Async closures would also provide the ability for users to run async benchmarks in differing runtime executors built for futures, rather than relying on \code{Driver} as the only option. See \cref{code:async_closures} for a theoretical example.

\begin{snippet}
\caption{Async flow in \toollinkedname.}\label{code:async_closures}
\begin{minted}{rust}
use futures::executor::block_on;
use vgpu_bench::prelude::*;

pub async fn benchmark() -> AsyncBenchmark {
    AsyncBenchmarkFn::new(async || {
        let mut measurements = Measurements::new();
        measurements.push(something_to.await);
        Ok(measurements)
    })
}

fn main() -> Result<()> {
    block_on(benchmark())?.write("results.csv")?;
    Ok(())
}
\end{minted}
\end{snippet}

\paragraph{Live Monitoring}
Sometimes visualization is more important than accuracy, and in such cases, we want to provide the ability to visualize a live, updating plot. This has the benefit of seeing live impact in an interactive demo, as opposed to annotating the behavior. Such a plot would update when a \code{Monitor} returns a polled value.