\section{Results}\label{sec:results}
As a method of verification of our work, we ask ``\textit{Are we building our framework right?}''. One way to verify our framework is to use it in a test trial and proving through construction. Therefore, we will offer a test trial to prove our framework's concept, design, and resourcefulness. We will then discuss the results in the following discussion section.

\subsection{Test Case}\label{sec:test_case}
We have chosen to verify our framework through use in a test trial. This trial to prove our framework's concept, design, and resourcefulness.

\subsubsection{The ``web browser'' case}\label{sec:web_browser_case}
Web browsers are the poster child for advancing vector graphics because of how ubiquitously used the browser technology is. Currently, Skia, discussed in section \cref{sec:skia}, is the graphics library that is used in modern web browsers. There is significant ongoing development that goes into optimizing web image rendering, given the empirical consequences. While formats such as SVG are generally smaller and faster to travel over the net in web pages (\cref{sec:storage_savings}), a slow rendering speed negates these benefits.\medskip

Our test trial will analyze a classic user story of vector graphics: static \textit{svg} content rendering. We will quantify the use of tessellation by rendering static graphics against three renderers which test if a pre-computation model such as tessellation may have usefulness in such a case.

\subsubsection{Questions for analysis}
We provide several questions that \toollinkedname will utilize to pilot our test case.
\begin{itemize}
    \item What are some consequences of tessellation?
    \item What are some consequences of a pre-computation model?
    \item Can hardware acceleration improve performance?
\end{itemize}

\subsubsection{Benchmarks}\label{sec:benchmarks}
We have coded several benchmarks using the \toollinkedname library to answer the above-mentioned questions. All benchmark source code in the ``thesis'' branches of the \toollinkedname repository\footnote{\toolrepo}, however results are taken from varying development stages of \toollinkedname, so our \textit{examples} on \textit{master}\footnote{\href{https://github.com/simbleau/vgpu-bench/tree/main/examples}{https://github.com/simbleau/vgpu-bench/tree/main/examples}} may provide the forward reader better content examples.

\begin{itemize}
% Profiling
    \item Path command output for several vector examples
    \item Tessellation triangle output for several vector examples
% Timing
    \item Tessellation timing for several primitives and amounts
% Rendering trials
    \item First frame output time of several vector examples
    \item Continuous frame times of several vector examples
% Consequences
    \item CPU Utilization of a complex example
\end{itemize}

\subsubsection{Instrumentation}
Below we provide justifications for our test data, tessellation backend, and rendering backends.

\paragraph{Hardware}
Unless otherwise specified, all GPU benchmarks are recorded with an NVIDIA\copyright \textit{GeForce 1060 3GB}, a middle-grade desktop-class GPU released in 2016.\medskip

\paragraph{Test data}
We use practical examples with varying complexity for a test set of vector graphics, supplemented with dynamically generated examples. Our dynamic examples have varying amounts of rotated primitives at a constant scale, generated with \textit{svg-generator} (\cref{sec:svg-generator}) to more consistently assess scalability.\medskip

In \cref{fig:vg_examples} we present five images that are practical in complexity and encountered naturally on the web. These images were chosen to represent assets such as logos, icons, and designs. Such images are purposed to represent the organic complexity of generalized vector graphics.\medskip
 
\widesvg
% Path
{assets/All.svg}
% Caption
{Several common vector graphics encountered on the web.\label{fig:vg_examples}}
% Attribution
{By Spencer C. Imbleau, MIT/Apache 2.0}\medskip

We also acknowledge that the web has apps that may utilize more paths and data than the images above. Fields such as graphic design, geographic information systems, and computer-aided design may require more computer resources. As such, we have cherry-picked one such example for analysis to represent a complex, resource-greedy image, which we present in \cref{fig:vg_complex}.\medskip

\svg
% Path
{assets/Complex.svg}
% Caption
{A complex vector image, ``\textit{KÃ¸benhavn\_512.svg}'', for benchmarking.\label{fig:vg_complex}}
% Attribution
{By Spencer C. Imbleau, MIT/Apache 2.0}

\paragraph{Tessellation}\label{sec:instrumentation_tessellator} In all benchmarks involving tessellation, \textit{Lyon}\footnote{\href{https://github.com/nical/lyon}{https://github.com/nical/lyon}} will be used as a backend library, given its academic profile\cite{Silva18}, performance\cite{Lyon_Sweep}, and modern application (\cref{sec:lyon_lit}). We will use a tolerance of \(0.1\) in all aspects where needed, which is a subjectively okay approximation.\medskip

\paragraph{Rendering}\label{sec:instrumentation_renderers} We will use three backend renderers to render all the provided test data above at the same scale and resolution. The first of which is \textit{resvg}\footnote{\href{https://github.com/RazrFalcon/resvg}{https://github.com/RazrFalcon/resvg}}, an optimized CPU-based renderer paralleling Skia. Secondly, we use \textit{Pathfinder}\footnote{\href{https://github.com/servo/pathfinder}{https://github.com/servo/pathfinder}}, a compute-centric sophisticated hardware-accelerated rendering library. Finally we use \textit{render-kit}'s own renderer (\cref{sec:render-kit}) as a tessellation-based renderer. Additional reasons and justifications may be found below, such that we may draw apt comparisons from varying rendering approaches.

\subparagraph{resvg} We have chosen \textit{resvg} because it is an abstraction over Skia\footnote{\href{https://skia.org}{https://skia.org}}, closely paralleling the optimization. Using a small subset of bindings from CPU-based Skia rendering, donned tiny-skia\footnote{\href{https://github.com/RazrFalcon/tiny-skia}{https://github.com/RazrFalcon/tiny-skia}}, tiny-skia is about 20-100\% less efficient than Skia\footnote{\href{https://razrfalcon.github.io/tiny-skia/x86_64.html}{https://razrfalcon.github.io/tiny-skia/x86\_64.html}}. Despite using no GPU features, \textit{resvg} is still one of the fastest CPU-based renderers for \textit{svg} images. We will also ignore any caching potential and produce every image as a dry run to provide optics on how beneficial caching may be.

\subparagraph{Render-Kit} As a feature of \toollinkedname, the ``\textit{render-kit}'' feature provides a minimal tessellation-based GPU renderer, with more information found in section \cref{sec:render-kit}. Since \textit{Pathfinder} uses an implementation of \textit{WebGPU}\footnote{\href{https://www.w3.org/TR/webgpu/}{https://www.w3.org/TR/webgpu/}}, it is portable and may compile to Web Assembly (WASM)\footnote{\href{https://webassembly.org/}{https://webassembly.org/}} as a hardware-accelerated web target, making this a practical candidate runtime for web browsers. WebGPU is developed by the \textit{W3C GPU for the Web Community Group} with engineers from Apple, Mozilla, Microsoft, Google, and others\cite{WebGPU}, such to extend hardware acceleration to the respective company's web browsers. \textit{Pathfinder} also uses minimal GPU features, namely a storage buffer for caching and multi-sample anti-aliasing.

\subparagraph{Pathfinder} Our last renderer for instrumentation is Pathfinder, with additional details found in section \cref{sec:Pathfinder}. \textit{Pathfinder} was engineered for work in Servo, an embedded web engine project. \textit{Pathfinder} offers an analytic approach to GPU-centric rendering, defended academically and publicly\cite{Walton18}. Pathfinder, as an interpreted model (\cref{sec:interpreted_models}), would provide a stark contrast to a tessellation-based model such as Render-Kit, or a heavily optimized CPU-based approach such as \textit{resvg}.

\subsection{Data Collection}
Data collected from the benchmarks in section \cref{sec:benchmarks} are given here. A discussion of these results may be found in the following section, \cref{sec:discussion}.

\subsubsection{Profiling}\label{sec:results_profiling}
% =========
% PROFILING
% =========
Results in this section are designed to profile several \textit{svg} images to classify images into a frame of reference for complexity.

\paragraph{SVG "True" Complexity}
In \cref{fig:complexity_svg} below, we plot data corresponding to the amount of path commands in each respective \textit{svg} image. Files are located on the x-axis. The volume of path commands in the respective file is plotted on the y-axis.\medskip

\widesvg
% Path
{results/profiling/svg_complexity.svg}
% Caption
{Total path commands in various \textit{svg} examples.\label{fig:complexity_svg}}
% Attribution
{By Spencer C. Imbleau, MIT/Apache 2.0}\medskip

\paragraph{SVG Tessellation Complexity}
In \cref{fig:complexity_tess} below, we plot data corresponding to the amount of output triangles for each respective \textit{svg} image after tessellation. Files are located on the x-axis. The volume of triangles produced in the respective file is plotted on the y-axis.\medskip

\widesvg
% Path
{results/profiling/tessellation_complexity.svg}
% Caption
{Total tessellated triangles in various \textit{svg} examples.\label{fig:complexity_tess}}
% Attribution
{By Spencer C. Imbleau, MIT/Apache 2.0}


\subsubsection{Tessellation}\label{sec:results_tessellation}
% ===================
% TESSELLATION TIMING
% ===================
Results in this section are designed to collect time trials relating to tessellation to understand more about the consequences of tessellation using our instrumentation tessellator (\cref{sec:instrumentation_tessellator}).

\paragraph{Low primitive count}
% =========================
% TESSELLATION TIMING - LOW
% =========================
In \cref{fig:less_triangle}, \cref{fig:less_quadratic_curve}, and \cref{fig:less_cubic_curve}, we plot the amount of time performed both in initialization and tessellation for low amounts of traditional vector primitives. The amount of primitives tessellated is located on the x-axis. The total time expense of both initialization and tessellation is recorded on the y-axis.\medskip

\widesvg
% Path
{results/tessellation/less_triangle.svg}
% Caption
{Loading and tessellation time for low amounts of \textit{svg} triangle primitives.\label{fig:less_triangle}}
% Attribution
{By Spencer C. Imbleau, MIT/Apache 2.0}\medskip

\widesvg
% Path
{results/tessellation/less_quadratic_bezier_curve.svg}
% Caption
{Loading and tessellation time for low amounts of \textit{svg} quadratic BÃ©zier curve primitives.\label{fig:less_quadratic_curve}}
% Attribution
{By Spencer C. Imbleau, MIT/Apache 2.0}\medskip

\widesvg
% Path
{results/tessellation/less_cubic_bezier_curve.svg}
% Caption
{Loading and tessellation time for low amounts of \textit{svg} cubic BÃ©zier curve primitives.\label{fig:less_cubic_curve}}
% Attribution
{By Spencer C. Imbleau, MIT/Apache 2.0}


\paragraph{High primitive count}
% ==========================
% TESSELLATION TIMING - HIGH
% ==========================
In \cref{fig:more_triangle}, \cref{fig:more_quadratic_curve}, and \cref{fig:more_cubic_curve}, we plot the amount of time performed both in initialization and tessellation for high amounts of traditional vector primitives. The amount of primitives tessellated is located on the x-axis. The total time expense of both initialization and tessellation is recorded on the y-axis.\medskip

\widesvg
% Path
{results/tessellation/more_triangle.svg}
% Caption
{Loading and tessellation time for high amounts of \textit{svg} triangle primitives.\label{fig:more_triangle}}
% Attribution
{By Spencer C. Imbleau, MIT/Apache 2.0}\medskip

\widesvg
% Path
{results/tessellation/more_quadratic_bezier_curve.svg}
% Caption
{Loading and tessellation time for high amounts of \textit{svg} quadratic BÃ©zier curve primitives.\label{fig:more_quadratic_curve}}
% Attribution
{By Spencer C. Imbleau, MIT/Apache 2.0}\medskip

\widesvg
% Path
{results/tessellation/more_cubic_bezier_curve.svg}
% Caption
{Loading and tessellation time for high amounts of \textit{svg} cubic BÃ©zier curve primitives.\label{fig:more_cubic_curve}}
% Attribution
{By Spencer C. Imbleau, MIT/Apache 2.0}


\subsubsection{Rendering Trials}\label{sec:results_rendering}
% ================
% RENDERING TRIALS
% ================
Results in this section are designed to collect time trials relating to rendering to understand more about the the performance of the differing renderers we use for instrumentation in section \cref{sec:instrumentation_renderers}.

\paragraph{Dry frametime for test data}
% ======================
% FIRST FRAME TIME - ALL
% ======================
In \cref{tab:first_frame_renderkit}, \cref{tab:first_frame_resvg}, and \cref{tab:first_frame_pathfinder}, we record the amount of time required to render each \textit{svg} image file one time as a dry run without any previous caching. These statistics include any required setup such as tessellation.\medskip

% Render-Kit
\begin{table}[H]
\centering
\begin{tabular}{ |c|c| }
\hline
\multicolumn{2}{|c|}{Dry Frametime, Render-Kit}\\
\hline
File&Frametime\\
\hline
ASU.svg&111.122763ms\\
\hline
Ferris.svg&110.129153ms\\
\hline
Flag\_of\_Denmark.svg&113.356655ms\\
\hline
Ghostscript\_Tiger.svg&119.625961ms\\
\hline
KÃ¸benhavn\_512.svg&813.996279ms\\
\hline
NASA.svg&110.726647ms\\
\hline
\end{tabular}
\caption{Dry frametime rendering for test data images with \textit{Pathfinder}.\label{tab:first_frame_renderkit}}
\end{table}
\medskip

% Resvg
\begin{table}[H]
\centering
\begin{tabular}{ |c|c| }
\hline
\multicolumn{2}{|c|}{Dry Frametime, Resvg}\\
\hline
File&Frametime\\
\hline
ASU.svg&845.686Âµs\\
\hline
Ferris.svg&2.819766ms\\
\hline
Flag\_of\_Denmark.svg&149.882Âµs\\
\hline
Ghostscript\_Tiger.svg&5.847163ms\\
\hline
KÃ¸benhavn\_512.svg&883.884497ms\\
\hline
NASA.svg&6.051327ms\\
\hline
\end{tabular}
\caption{Dry frametime rendering for test data images with \textit{resvg}.\label{tab:first_frame_resvg}}
\end{table}
\medskip

% Pathfinder
\begin{table}[H]
\centering
\begin{tabular}{ |c|c| }
\hline
\multicolumn{2}{|c|}{Dry Frametime, Pathfinder}\\
\hline
File&Frametime\\
\hline
ASU.svg&2.328747ms\\
\hline
Ferris.svg&2.279044ms\\
\hline
Flag\_of\_Denmark.svg&2.116318ms\\
\hline
Ghostscript\_Tiger.svg&3.38733ms\\
\hline
KÃ¸benhavn\_512.svg&80.38817ms\\
\hline
NASA.svg&5.456171ms\\
\hline
\end{tabular}
\caption{Dry frametime rendering for test data images with \textit{Pathfinder}.\label{tab:first_frame_pathfinder}}
\end{table}

\paragraph{Wet frametimes for test data}\label{sec:wet_frametimes}
% =====================
% WET FRAME TIMES - ALL
% =====================
In \cref{fig:wet_all_renderkit}, \cref{fig:wet_all_resvg}, and \cref{fig:wet_all_pathfinder}, we plot the frametimes of our test data. Frames are measured by continuously rendering \emph{after} setup steps such as tessellation, staging, or initialization. The frame rendered is recorded on the x-axis. The total time expense of rendering is recorded on the y-axis.\medskip

\widesvg
% Path
{results/rendering/all/all_renderkit.svg}
% Caption
{Frametime stability of all test data over 50 frames, rendered by \textit{Pathfinder}.\label{fig:wet_all_renderkit}}
% Attribution
{By Spencer C. Imbleau, MIT/Apache 2.0}\medskip

\widesvg
% Path
{results/rendering/all/all_resvg.svg}
% Caption
{Frametime stability of all test data over 50 frames, rendered by \textit{resvg}.\label{fig:wet_all_resvg}}
% Attribution
{By Spencer C. Imbleau, MIT/Apache 2.0}\medskip

\widesvg
% Path
{results/rendering/all/all_pathfinder.svg}
% Caption
{Frametime stability of all test data over 50 frames, rendered by \textit{Pathfinder}.\label{fig:wet_all_pathfinder}}
% Attribution
{By Spencer C. Imbleau, MIT/Apache 2.0}

\paragraph{Wet frametimes for a simple image}
% ======================
% WET FRAME TIMES - FLAG
% =======================
In \cref{fig:wet_flag_renderkit}, \cref{fig:wet_flag_resvg}, and \cref{fig:wet_flag_pathfinder}, we plot the frametimes of our most simple item of test data, ``\textit{Flag\_of\_Denmark.svg}''. Frames are measured by continuously rendering \emph{after} setup steps such as tessellation, staging, or initialization. The frame rendered is recorded on the x-axis. The total time expense of rendering is recorded on the y-axis.\medskip

\widesvg
% Path
{results/rendering/flag_dk/flag_renderkit.svg}
% Caption
{Frametime stability of a simple \textit{svg} ``\textit{Flag\_of\_Denmark.svg}'' over 50 frames, rendered by \textit{Pathfinder}.\label{fig:wet_flag_renderkit}}
% Attribution
{By Spencer C. Imbleau, MIT/Apache 2.0}\medskip

\widesvg
% Path
{results/rendering/flag_dk/flag_resvg.svg}
% Caption
{Frametime stability of a simple \textit{svg} ``\textit{Flag\_of\_Denmark.svg}'' over 50 frames, rendered by \textit{resvg}.\label{fig:wet_flag_resvg}}
% Attribution
{By Spencer C. Imbleau, MIT/Apache 2.0}\medskip

\widesvg
% Path
{results/rendering/flag_dk/flag_pathfinder.svg}
% Caption
{Frametime stability of a simple \textit{svg} ``\textit{Flag\_of\_Denmark.svg}'' over 50 frames, rendered by \textit{Pathfinder}.\label{fig:wet_flag_pathfinder}}
% Attribution
{By Spencer C. Imbleau, MIT/Apache 2.0}


\paragraph{Wet frametimes for a complex image}
% =====================
% WET FRAME TIMES - MAP
% =====================
In \cref{fig:wet_map_renderkit}, \cref{fig:wet_map_resvg}, and \cref{fig:wet_map_pathfinder}, we plot the frametimes of our most complex item of test data, ``\textit{KÃ¸benhavn\_512.svg}''. Frames are measured by continuously rendering \emph{after} setup steps such as tessellation, staging, or initialization. The frame rendered is recorded on the x-axis. The total time expense of rendering is recorded on the y-axis.\medskip

\widesvg
% Path
{results/rendering/map_dk/map_renderkit.svg}
% Caption
{Frametime stability of a complex \textit{svg} ``\textit{KÃ¸benhavn\_512.svg}'' over 50 frames, rendered by \textit{Render-Kit}.\label{fig:wet_map_renderkit}}
% Attribution
{By Spencer C. Imbleau, MIT/Apache 2.0}\medskip

\widesvg
% Path
{results/rendering/map_dk/map_resvg.svg}
% Caption
{Frametime stability of a complex \textit{svg} ``\textit{KÃ¸benhavn\_512.svg}'' over 50 frames, rendered by \textit{resvg}.\label{fig:wet_map_resvg}}
% Attribution
{By Spencer C. Imbleau, MIT/Apache 2.0}\medskip

\widesvg
% Path
{results/rendering/map_dk/map_pathfinder.svg}
% Caption
{Frametime stability of a complex \textit{svg} ``\textit{KÃ¸benhavn\_512.svg}'' over 50 frames, rendered by \textit{Pathfinder}.\label{fig:wet_map_pathfinder}}
% Attribution
{By Spencer C. Imbleau, MIT/Apache 2.0}\medskip


\subsubsection{Monitoring}\label{sec:results_monitoring}
% ===============================
% CPU UTILIZATION - KÃBENHAVN_512
% ===============================
Results in this section are designed to monitor consequences incurred by a file with a heavy resource footprint.\medskip

In \cref{tab:wet_map_renderkit}, \cref{tab:wet_map_resvg}, and \cref{tab:wet_map_pathfinder}, we record the cpu utilization for ten seconds while rendering our most complex item of test data, ``\textit{KÃ¸benhavn\_512.svg}''. The process responsible for rendering is initiated by a user.\medskip

% Render-Kit
\begin{table}[H]
\centering
\begin{tabular}{ |c|c|c|c|c|c| }
\hline
\multicolumn{6}{|c|}{CPU Utilization Rendering KÃ¸benhavn\_512.svg, Render-Kit}\\
\hline
Second&Idle&Interrupt&Nice&System&User\\
\hline
1&0.467693&0.0&0.0&0.037544124&0.49476284\\
\hline
2&0.39563155&0.0&0.0&0.067370936&0.5369975\\
\hline
3&0.495704&0.0&0.0&0.021988489&0.48169076\\
\hline
4&0.53159183&0.0&0.0&0.02529972&0.44310844\\
\hline
5&0.5278983&0.0&0.0&0.02840928&0.44369245\\
\hline
6&0.46954525&0.0&0.0&0.045535572&0.4849192\\
\hline
7&0.45059177&0.0&0.0&0.0710343&0.47837391\\
\hline
8&0.50600004&0.0&0.0&0.09704739&0.39521644\\
\hline
9&0.5059884&0.0&0.0&0.051762626&0.41293645\\
\hline
10&0.46378028&0.0&0.0&0.034738675&0.50148106\\
\hline
\end{tabular}
\caption{CPU Utilization over ten seconds of rendering a complex \textit{svg} ``\textit{KÃ¸benhavn\_512.svg}'' with \textit{Render-Kit}.\label{tab:wet_map_renderkit}}
\end{table}
\medskip

% Resvg
\begin{table}[H]
\centering
\begin{tabular}{ |c|c|c|c|c|c| }
\hline
\multicolumn{6}{|c|}{CPU Utilization Rendering KÃ¸benhavn\_512.svg, Resvg}\\
\hline
Second&Idle&Interrupt&Nice&System&User\\
\hline
1&0.84086835&0.0&0.0&0.023640312&0.1219778\\
\hline
2&0.85577947&0.0&0.0&0.0039034719&0.13270414\\
\hline
3&0.8671819&0.0&0.0&0.0009431307&0.12520833\\
\hline
4&0.85061646&0.0&0.0&0.020844596&0.12853892\\
\hline
5&0.78110397&0.0&0.0&0.054991208&0.16390486\\
\hline
6&0.85544133&0.0&0.0&0.014675165&0.1298835\\
\hline
7&0.84812915&0.0&0.0&0.014469341&0.13740154\\
\hline
8&0.80173135&0.0&0.0&0.013854485&0.13774753\\
\hline
9&0.8667649&0.0&0.0&0.04184088&0.091394216\\
\hline
10&0.85680187&0.0&0.0&0.0139503265&0.12924781\\
\hline
\end{tabular}
\caption{CPU Utilization over ten seconds of rendering a complex \textit{svg} ``\textit{KÃ¸benhavn\_512.svg}'' with \textit{resvg}.\label{tab:wet_map_resvg}}
\end{table}

% Pathfinder
\begin{table}[H]
\centering
\begin{tabular}{ |c|c|c|c|c|c| }
\hline
\multicolumn{6}{|c|}{CPU Utilization Rendering KÃ¸benhavn\_512.svg, Pathfinder}\\
\hline
Second&Idle&Interrupt&Nice&System&User\\
\hline
1&0.92592514&0.0&0.0&0.013025147&0.06104972\\
\hline
2&0.7673017&0.0&0.0&0.16913769&0.06356061\\
\hline
3&0.97890556&0.0&0.0&0.00616342&0.014931006\\
\hline
4&0.97474915&0.0&0.0&0.007291886&0.017959006\\
\hline
5&0.8870437&0.0&0.0&0.0076014614&0.052989975\\
\hline
6&0.85821474&0.0&0.0&0.011255654&0.063322365\\
\hline
7&0.91479445&0.0&0.0&0.005&0.08020559\\
\hline
8&0.9161637&0.0&0.0&0.017694628&0.06614172\\
\hline
9&0.9035666&0.0&0.0&0.025771506&0.070661925\\
\hline
10&0.93193793&0.0&0.0&0.00093627756&0.06712583\\
\hline
\end{tabular}
\caption{CPU Utilization over ten seconds of rendering a complex \textit{svg} ``\textit{KÃ¸benhavn\_512.svg}'' with \textit{Pathfinder}.\label{tab:wet_map_pathfinder}}
\end{table}


%===================
% TEST CASE ANALYSIS
%===================


\subsection{Test Case Analysis}
This section interprets the several benchmarks and data collected in the results above. Precisely, we will interpret findings from our analysis questions regarding our test case.\medskip

\subsubsection{Consequences of tessellation}
In our questions for analysis, we asked ``What are some consequences of tessellation?''. Below we will explain our findings for this query.\medskip

\paragraph{Primitive count} Tessellation does not always output more complexity than the original vector image. In the example of ``\textit{Flag\_of\_Denmark.svg}'' in our profiling results (\cref{sec:results_profiling}) we notice the original file contains 18 path commands, and the tessellation outputs 12 triangles. This intuitively makes sense, as the flag may be represented with two triangles for each rectangle, with the flag being able to be described as six rectangles.

\paragraph{Tolerance} One may point out that ``\textit{Ferris.svg}'' has far less path commands than ``\textit{ASU.svg}'' in their original \textit{svg} files, but produces far more triangles during tessellation. Upon further investigation, this is because of curve flattening and a tolerance, described more in section \cref{sec:tessellation}. ``\textit{ASU.svg}'' has many more paths due to the text ``\textit{Mountaineers}'' over the logo, which are subtracted away during curve flattening simplification, a function of tolerance.

\paragraph{Tessellation costs} Given an svg with varying amounts of primitives, tessellation costs a lot. If we ignore all initialization cost required to de-serialize an \textit{svg}, which is usually higher than tessellation cost itself according to our results, tessellation is still expensive. Performing a simple linear regression on time residuals gives fairly precise predictions of tessellation time cost as volume of primitives increases. These results suggest that a few thousand primitives will start to incur several milliseconds of cost regardless of type.

\subparagraph{Triangle tessellation cost}
\tocequation{Equation of triangle tessellation cost}
\begin{equation}\label{eq:tesscost_triangle}
f(x)=0.00044ms*x-0.1022ms
\end{equation}
\begin{center}
where \(x\) is the amount of triangle primitives to tessellate.\\
Correlation: \(r=0.996\)\\
R-squared:	\(r^2=0.993\)
\end{center}

\subparagraph{Quadratic BÃ©zier curve tessellation cost}
\tocequation{Equation of quadratic BÃ©zier curve tessellation cost}
\begin{equation}\label{eq:tesscost_quadratic_bezier}
f(x)=0.00035ms*x+1.0694ms
\end{equation}
\begin{center}
where \(x\) is the amount of quadratic BÃ©zier curve primitives to tessellate.\\
Correlation: \(r=0.998\)\\
R-squared:	\(r^2=0.997\)
\end{center}

\subparagraph{Cubic BÃ©zier curve tessellation cost}
\tocequation{Equation of cubic BÃ©zier curve tessellation cost}
\begin{equation}\label{eq:tesscost_cubic_bezier}
f(x)=0.00039ms*x+3.9174ms
\end{equation}
\begin{center}
where \(x\) is the amount of cubic BÃ©zier curve primitives to tessellate.\\
Correlation: \(r=0.968\)\\
R-squared:	\(r^2=0.937\)
\end{center}

\subsubsection{Consequences of pre-computation}
In our questions for analysis, we asked ``What are the consequences of a pre-computation model?''. Below we will explain our findings for this query.\medskip

\paragraph{Cache-friendliness}
Pre-computation is proven useful in situations where vectors do not have to be deformed or rescaled, such as in the web browser case. Furthermore, Pre-computation may use caching to reduce computation in future rendering iterations. For example, in our benchmarks recording continuous ``dry'' and ``wet'' frametimes, we recorded a single frame turnaround and continuous frametimes for three renderers. Since we did not use any caching features with \textit{resvg}, \textit{resvg}'s dry frametimes are approximately equal to its wet frametimes. On the contrary, render-kit's only GPU feature is a storage buffer binding to tessellation data for computation re-use. This removed the need to re-tessellate per frame, improving the frametime of subsequent frames by a magnitude of 10.

\paragraph{Interactivity} While pre-computation may help to reduce recalculation and improve performance through recycling, the model is anti-thetic to interactivity such as animation or live deformation such as scaling. A reasonable goal is to render an image within \(16ms\), the reciprocal of \(60fps\) (frames per second), a standard convention for interactivity. In our case we only consider static content, so this is not such an issue, but it should be noted that our test case is both narrow and naive for brevity.

\subsubsection{Hardware-acceleration}
In our questions for analysis, we asked ``How can hardware-acceleration improve performance?''. Below we will explain our findings for this query.\medskip

\paragraph{GPU latency} Hardware acceleration always brings latency when interacting with the GPU, so in some cases, hardware acceleration is not the magic solution some believe. In elementary vector images with low complexity, \textit{resvg} beat both \textit{Pathfinder} and \textit{Render-Kit} which both leverage the GPU. In the case of \textit{Render-Kit}, there is an nonnegotiable \(110ms\) of submit latency in buffer allocation and transfer required for an initial frame. Viewing the NVTX annotations while running \textit{Pathfinder} provides us with the details to prove this. We have annotated the first frame as ``Strange Behavior'' in NVIDIA\copyright \textit{Nsight Systems}\footnote{\href{https://developer.nvidia.com/nsight-systems}{https://developer.nvidia.com/nsight-systems}} to show this behavior in \cref{fig:strange_behavior}. The metric samples show a build-up to a GPU queue submit, thereby triggering a compute dispatch to commit DRAM for reading subsequent frames.\medskip

\widesvg
% Path
{assets/Nsight_Systems_Renderkit.svg}
% Caption
{Initial GPU latency of \textit{Render-Kit}, annotated by \toollinkedname.\label{fig:strange_behavior}}
% Attribution
{By Spencer C. Imbleau, MIT/Apache 2.0}
\medskip

Since \textit{Pathfinder} interprets vector graphics mainly through shaders, there is minor caching or pre-computation, and less ceremony is required for an initial frame. However, even with no caching, there still exists an unnegotiable \(2ms\) of GPU latency on our test hardware.

\paragraph{Compute-centricity} \textit{Pathfinder} mollifies historical pipeline rigidity by utilizing compute shaders for parallel winding number computation (\cref{sec:Pathfinder}). This pipeline results in efficient rendering on the GPU in almost all cases, except for elementary ones. Against a traditional raster pipeline, \textit{Render-Kit} provided no competition, with \textit{Pathfinder} being exceptionally better in all cases.\medskip

\paragraph{CPU Utilization} There is also significantly lower CPU utilization monitored with a compute-centric approach, suggesting an intention of increased GPU leveraging and parallelization.

\paragraph{GPU-caching} Although \textit{resvg} offers one of the most optimized backends for rasterizing vector graphics, the renderer failed to outperform the minimal tessellation-based renderer in \textit{render-kit} by a lack of caching ability.
